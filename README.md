# Курс по архитектуре. Спринт 1

### Задание 1

Нужно было разделить монолитный фронтенд на микрофронты. Я выделил три сервиса
* `main` - собирает фронты, отвечает за общение с бэком и отображение всей информации;
* `auth` - отвечает за логин и регистрацию;
* `popup` - отвечает за все попапы.

Для реализации я использовал Webpack Module Federation. Композиция на уровне клиента - каждый фронт билдится отдельно и выкачивается со своего адреса в момент рендеринга страницы. Общение происходит за счет библиотеки redux - передается пользователь.

Чтобы все запустить, сначала нужно запустить `auth` и `popup` (`npm start`), а только потом `main`. В данный момент сайт не работает, как ожидается - у меня не подгружаются стили и я не знаю, как это исправить. Я бы продолжил дальше разбивать фронт, как минимум выделил бы `card` и `profile`, но у меня пока не получилось совладать с webpack и запустить хотя бы на три сервиса. Я делал итеративно и на двух сервисах (main и auth) все работало. 90% времени я потратил на то, чтобы исправить возникающие ошибки с Webpack и React, теоретически в задании все понятно.


### Задание 2

Я разбил монолит на микросервисы по бизнес задачам. Каждый сервис ожидает получение JWT токена, ключ для которого запрашивается у сервиса авторизации и сохранятеся в локальном кэше.

https://github.com/maxbolgarin/architecture-sprint-1/blob/sprint-1/praktikum_arch_bolgarin.xml


## Update

### Задание 1

Опишу разделение на микрофронты, которое я бы реализовал:

* `main` — собирает фронты, отвечает за общение с бэком и отображение всей информации.
* `auth` — отвечает за логин и регистрацию.
* `profile` — отвечает за профиль пользователя, вывод информации; берется часть кода из `Main.js` и выделяется в отдельную компоненту.
* `card` — отвечает за отображение карточек и взаимодействие с ними; выносится текущая компонента `Card`, которая используется компонентой `Main`.

### Задание 2

#### Описание микросервисов:

* Обратный прокси — нужен для формирования единой точки взаимодействия бэкенда и фронтенда; фронтэнд может ходить только в один эндпоинт, а его запросы будут маршрутизироваться по пути.
* Авторизация — нужен для выдачи JWT токена (если точнее — два токена, access и refresh) пользователю для обращения к другим сервисам; в самом токене лежит необходимая информация для авторизации пользователя в других сервисах. Каждый сервис забирает из auth сервиса ключ для дешифровки токенов.
* Пользователи — сервис для работы пользовательского профиля.
* Заказы — сервис для работы с заказами, которые создает пользователь; также он взаимодействует с сервисом платежей для обработки оплаты заказов.
* Платежи — сервис для обработки платежей путем взаимодействия с внешними платежными системами.
* Услуги — сервис для работы с услугами; в монолитном бэкенде не было функций для работы с услугами, но я решил добавить, так как эта функциональность заявлена на фронтенде.
* Поиск — сервис для формирования поисковых запросов; в монолитном бэкенде была такая функционалбность, но ее не было на фронтенде, поэтому я добавил.
* Аукционы — сервис для работы с аукционами.
* Заявки — сервис для формирование и обработки разнообразных заявок.
* Отчеты — внутренний сервис для генерации отчетов.


#### Опциональные комментарии:

> нельзя ли валидировать JWT один раз, например где нибудь в единой точке входа и далее уже работать как с "доверенным" запросом? в каком компоненте это можно было бы сделать? можно подумать над плюсами и минусами текущего и предлагаемого решения

Да, можно вынести валидацию токена на уровень маршрутизации запросов от фронтенда (в моей схеме это обратный прокси).

* Плюсы: не нужно писать код проверки токена в каждом сервисе; не нужно синхронизировать ключ расшифровки JWT между многими сервисами; будет меньше неавторизированного трафика внутри кластера.
* Минусы: усложняется настройка маршрутизатора вплоть до написания своего кода - сервис должен уметь синхронизировать ключ с сервисом Авторизации. Кроме того, если каждый сервис сам проверял токен, то он мог сам определяеть, пользователи с какими ролями могут к нему обращаться; если использовать централизованную проверку, то этот API Gateway (это уже не обратный прокси) должен уметь по разному авторизовать запрос в зависимости от конечного получателя.


> про shared database и его альтернатива database per service. 

Подход database per service также обладает минусами, так как требует дополнительной разработки и нагрузки на devops. С другой стороны этот подход обеспечивает большую гранулярность, и точно следует начать с выноса тех сущностей, которые не имеют сильных зависимостей с другими. Например, для начала можно выделить авторизационную информацию пользователя, по типу логина и пароля и тд. Далее по БД для аукционов и услуг, так как они не сильно связаны с другими сущностями в базе. Затем сделать отдельную базу для платежей, так как она более требовательна к надежности. Ну и так далее. 


> подумать над интерфейсом взаимодействия ролей Администратора и Спеца поддержки (сейчас они общаются напрямую с критичными бизнес сервисами, возможно тут можно что то улучшить)

Для этого можно добавить панель администратора на фронтенд, а также добавить дополнительные роли пользователя. Они бы ходили так же, как и обычные пользователи, но к их аккаунтам были бы привязаны сооветствующие права, позволяющие обращаться к нужным им сервисам.